The cosimulation environment validates the RTL design by executing a program in lock-step
in both the Verilog RTL model and functional simulator. The test harness compares instruction side
effects--register writebacks and memory stores--to ensure they match. Test programs can be real programs 
as well as random instruction sequences generated by a utility. 

Randomized cosimulation is a common processor verification technique. Here are a few papers  
that describe how it is used for some commercial processors:

* [Functional Verification of a Multiple-issue, Out-of-Order, Superscalar Alpha Processorâ€” The DEC Alpha 21264 Microprocessor](http://www.cs.clemson.edu/~mark/464/21264.verification.pdf) 
* [Functional Verification of the HP PA 8000 Processor](http://www.cs.clemson.edu/~mark/464/hp8000.verification.pdf) 
* [Verification of the Cell Broadband Engine Processor](http://www.cs.york.ac.uk/rts/docs/DAC-1964-2006/PAPERS/2006/DAC06/PDFFILES/P0338.PDF) 
* [PicoJava II Verification Guide](http://www1.pldworld.com/@xilinx/html/pds/HDL/picoJava-II/docs/pj2-verif-guide.pdf)

# Executing Tests

Tests can be invoked directly like this:

    ./runtest.py <filename>

&lt;filename&gt; can an assembly file (.s), which will be assembled
before execution, or a hex file, which will be executed directly. 

_The cosimulator only works in single-core configurations._

To debug issues, it is often desirable to see the actual instructions.  The listing file can be generated like this:

    usr/local/llvm-vectorproc/bin/llvm-objdump --disassemble WORK/test.elf > test.dis

And a trace can be generated by setting the SIMULATOR_DEBUG_ARGS environment variable:

    SIMULATOR_DEBUG_ARGS=-v ./runtest.sh ...

### Simulator Random Seed

When simulation starts, the program will print:
<pre>
Random seed is 1405877782
</pre>

Verilator is a 2-state simulator. While a single bit in a standard Verilog simulator can have 4 states: 
0, 1, X, and Z, Verilator only supports 0 and 1. As an alternative, Verilator allows setting random values 
for signals that are assigned X or Z.  This is a useful feature, since it allows catching failures 
that wouldn't be visible in a normal Verilog simulator because of inherent flaws in the way the Verilog 
specification defines X and Z. This paper http://www.arm.com/files/pdf/Verilog_X_Bugs.pdf gives a good description 
of those issues.

An implication of this is that that programs will run run-to-run because all signals are not explicitly 
initialized at reset (SRAMs, for example, are not).  To get consistent behavior run-to-run, change 
rtl/vn/testbench/verilator_main.cpp to hardcode the random seed to a fixed value.  This is useful when
performing multiple runs to isolate a specific failure.

# Generating New Random Test Program
 
Use the generate.py script in the cosimulation directory to generate random test programs

    python ./generate_random_v1.py [-o output file] [-p profile] [-n number of instructions] [-m number of files]

Output will be written into the file 'random.s' by default.  The instruction
profile can currently be 0-3 and will be discussed in more detail below.

The -m file allows generating multiple test files.  For example:

    mkdir tests
    cd tests
    python ../generate_random_v1.py -m 100

These can then be run like this:

    cd ..
    ./runtest tests/*

## Instruction Selection for Random Program Generation
 
Using a completely unbiased random distribution of instructions doesn't give 
great coverage. It is desirable to adjust the distribution of instructions 
to exercise different architectural areas. The probabilities of different instruction
types are currently hardcoded in the generator program

### Branches
 
We want to avoid creating infinite loops. To ensure this, branches can
only be forward. Additionally, we only allow a forward branch of up to 8
instructions to avoid skipping too much code.

### Memory accesses

We must avoid accessing invalid memory addresses, which would occur
if we used random register values for pointers. The generation program reserves three registers to act as 
memory pointers, which are guaranteed to be valid addresses.  s0/v0 points to the base of a shared region, 
which all strands may read from s1/v1 is the base of a private, per-thread region that all each thread may 
write to.  s2/v2 is pointer into the private region, computed from s1/v1. This is used to validate 
instruction RAW dependency checking for memory operations.

The test generator will choose random offsets for the memory access
instructions, which allows hitting different cache lines in that region
and generates a good mix of L1/L2 cache misses and hits. The alignment
of these 5 regions a multiple of L2 cache size so that aliasing of
the lines occurs.  This allows verifying L2 cache writebacks.

There is code in the Verilog testbench to copy all dirty L2 cache lines back to memory so it can be
compared, as the random test program will not explicitly
flush them. The C model does not emulate the caches.

_Currently, the testbench does not support a processor reading from 
addresses that another is writing to.  The simulator does not model the 
behavior of the store buffer, so we can't simulate this is a cycle accurate
manner yet._


# How it works
## Checking
 
When the verilog simulator is invoked with the +regtrace=1 flag, it will
print ASCII lines describing instruction side effects to stdout. These include:
* vector register writeback 
* scalar register writeback 
* memory store 

Each debug record includes the PC and thread of the instruction that caused it,
and register/address information specific to the instruction.

The functional simulator (tools/simulator) is a C program that
simulates behavior of the instruction set, parses the textual output
from the Verilog simulator.  It it possible to use something like VPI to
directly call into the simulator, but text output is used instead for
simplicity.

Each time the simulator parses one of these operations, it steps the strand
that is referenced in the instruction.  If instructions are executed
that don't have side effects (for example, a branch), it continues
stepping until it encounters one that does.  It then compares the side
effect of the instruction with the result from the Verilog simulator and
flags an error if there is a mismatch.

Some sequences of instructions may be order dependent. The instruction
accurate simulator does not faithfully reproduce order of instruction
issue. This mechanism mitigates that by allowing the Verilog simulator
to control ordering of instruction issue, while still rigorously
checking that the program state is accurate.

_However, the simulator does not currently model the behavior of the
store buffer. Since the store buffer affects visibility of writes to
other strands, this means the simulator can't accurately handle
reads/writes to the same cache lines from multiple threads. As such, the
random test generator currently reserves a separate write region for
each strand. The v2 architecture does not have this constraint._

