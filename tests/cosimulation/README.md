The cosimulation environment validates the RTL design in simulation.  It
works by executing a program in both the Verilog simulator and the C
based simulator in lock-step and checking that each register writeback
and memory store (to the L1 cache) matches. Additionally, there are a
number of internal assertions in the Verilog model that will check for
invalid states. This test can execute complex assembly tests (for
example, simple encryption) as well as random instruction sequences
generated by a utility.

Randomized cosimulation is fairly common in processor verification. 
Here are a few papers that discuss methodologies used for some
commercial processors:

* [Functional Verification of a Multiple-issue, Out-of-Order, Superscalar Alpha Processorâ€” The DEC Alpha 21264 Microprocessor](http://www.cs.clemson.edu/~mark/464/21264.verification.pdf) 
* [Functional Verification of the HP PA 8000 Processor](http://www.cs.clemson.edu/~mark/464/hp8000.verification.pdf) 
* [Verification of the Cell Broadband Engine Processor](http://www.cs.york.ac.uk/rts/docs/DAC-1964-2006/PAPERS/2006/DAC06/PDFFILES/P0338.PDF) 
* [PicoJava II Verification Guide](http://www1.pldworld.com/@xilinx/html/pds/HDL/picoJava-II/docs/pj2-verif-guide.pdf)

# Executing Tests

The test can be invoked directly like this:

    ./runtest.py <testname>

&lt;testname&gt; can an assembly file (.s), which will be assembled
before execution, or a hex file, which will be executed directly. _Note
that these tests will not work properly with multiple cores enabled
(only one is enabled by default)_

To debug issues, it is often desirable to see the actual instructions.  The listing file can be generated like this:

    usr/local/llvm-vectorproc/bin/llvm-objdump --disassemble WORK/test.elf > test.dis

And a trace can be generated by setting the SIMULATOR_DEBUG_ARGS environment variable:

SIMULATOR_DEBUG_ARGS=-v ./runtest.sh ...

# Generating new random test vectors
 
Use the generate.py script in the cosimulation directory:

    python ./generate_random_v1.py [-o output file] [-p profile] [-n number of instructions] [-m number of files]

Output will be written into the file 'random.s'.  The instruction
profile can currently be 0-3 and will be discussed in more detail below.

The -m file allows generating multiple test files.  For example:

    mkdir tests
    cd tests
    python ../generate_random_v1.py -m 100

These can then be run like this:

    cd ..
    ./runtest tests/*

## Instruction selection for Random Vector Generation
 
It has been found that using a completely unbiased random distribution
of instructions doesn't give great coverage. It is desirable to manually
adjust the distribution of instructions to exercise different
architectural areas. There are a number of profiles of instruction
probabilities hard coded into the test program, which can be selected on
the command line.

### Branches
 
We want to avoid creating infinite loops. To ensure this, branches can
only be forward. Additionally, we only allow a forward branch of up to 8
instructions to avoid skipping too much code.

### Memory accesses

We want to avoid accessing invalid memory addresses, which would occur
if we used random register values for pointers. This is handled by
reserving two registers to act as memory pointers.  s0 points to the
base of a shared region, which all strands may read from (v0 also
contains the same value in all lanes for gather loads).

The test generator will choose random offsets for the memory access
instructions, which allows hitting different cache lines in that region
and generates a good mix of L1/L2 cache misses and hits. The alignment
of these 5 regions is chosen to be the L2 cache size so that aliasing of
the lines occurs.  This allows verifying L2 cache writebacks.

It should also be noted that there is code in the Verilog testbench to
automatically copy all dirty L2 cache lines back to memory so it can be
compared, as the randomly generated test program will not explicitly
flush them. The C model does not emulate the caches.

_Currently, the test does not support a processor reading from addresses
that another is writing to.  The simulator does not model the behavior
of the store buffer, so we can't simulate this is a cycle accurate
manner yet._

# How it works
## Checking
 
When the verilog simulator is invoked with the +regtrace=1 flag, it will
print ASCII  about instruction execution to standard out.  These use the
following forms (all numerical values are hexadecimal):

**vwriteback** _pc_ _strand_ _register_ _mask_ _value_<br> Vector
register writeback.  Ex:

vwriteback 000000018 0 01 fdff
033fffff07ffffff03dbffff01ffffff05ffffff0b25ffffffffffff0753ffff01dcffff
0b7fffff0ecfffff0064ffff0597ffff07ffffff053fffff09d3ffff

**swriteback** _pc_ _strand_ _register_ _value_<br> Scalar register
writeback.  Ex:

swriteback 000000010 0 02 0000fdff

**store** _pc_ _strand_ _address_ _mask_ _data_<br> Store to cache. 
This will always display a full cache line work of data, aligned on a
cache line boundary. The mask field selecting which bytes should of that
data should be written.  Any bytes not selected by the mask are
undefined. Ex:

store 00000028 0 00000040 0000004000000000
000a0000000a0000000a0000000a0000000a0000000a0000000a0000000a0000000a0000
000a0000000a0000000a0000000a0000000a0000000a0000000a0000

The instruction accurate simulator (IAS), which is a C program that
simulates behavior of the instruction set, parses the textual output
from the Verilog simulator.  It it possible to use something like VPI to
directly call into the IAS, but text output is used instead for
simplicity.

Each time the IAS parses one of these operations, it steps the strand
that is referenced in the instruction.  If instructions are executed
that don't have side effects (for example, a branch), it continues
stepping until it encounters one that does.  It then compares the side
effect of the instruction with the result from the Verilog simulator and
flags an error if there is a mismatch.

Some sequences of instructions may be order dependent. The instruction
accurate simulator does not faithfully reproduce order of instruction
issue. This mechanism mitigates that by allowing the Verilog simulator
to control ordering of instruction issue, while still rigorously
checking that the program state is accurate.

_However, the simulator does not currently model the behavior of the
store buffer. Since the store buffer affects visibility of writes to
other strands, this means the simulator can't accurately handle
reads/writes to the same cache lines from multiple threads. As such, the
random test generator currently reserves a separate write region for
each strand. This should be addressed in the future._

