# 
# Copyright (C) 2014 Jeff Bush
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
# Boston, MA  02110-1301, USA.
# 

#
# Generate a pseudorandom instruction stream.
# This is specifically constrained for the V2 microarchitecture.
#
# v0, s0 - Base registers for data segment
# v1, s1 - Computed address registers.  Guaranteed to be 64 byte aligned and in memory segment.
# v2-v8, s2-s8 - Operation registers
#
# Data memory starts after code
#

import random
import sys
import argparse

FFORMS = [
	('s', 's', 's', ''),
	('v', 'v', 's', ''),
	('v', 'v', 's', '_mask'),
	('v', 'v', 'v', ''),
	('v', 'v', 'v', '_mask'),
]

IFORMS = [
	('s', 's', 's', ''),
	('v', 'v', 's', ''),
	('v', 'v', 's', '_mask'),
	('v', 'v', 'v', ''),
	('v', 'v', 'v', '_mask'),
	('s', 's', 'i', ''),
	('v', 'v', 'i', ''),
	('v', 'v', 'i', '_mask'),
	('v', 's', 'i', ''),
	('v', 's', 'i', '_mask'),
]

BINOPS = [
	'or',
	'and',
	'xor',
	'add_i',
	'sub_i',
	'ashr',
	'shr',
	'shl',
	'mul_i'
#	'add_f',
#	'sub_f',
#   'mul_f'
]

UNOPS = [
	'clz',
	'ctz',
	'move'
]

def generate_test(filename, numInstructions):
	file = open(filename, 'w')
	file.write('# This file auto-generated by ' + sys.argv[0] + '''

				.globl _start
	_start:		move s1, 15
				setcr s1, 30	; start all threads
			
				; Initialize registers
				move s3, 4051
				move s4, s3
				move s5, s3
				xor s6, s5, s4
				move s7, s6
				move s8, 0
				move v2, 0
				move v3, s3
				move v4, s4
				move v5, s5
				move v6, s6
				move v7, s7
				move_mask v3, s7, v4
				move_mask v4, s6, v5
				move_mask v5, s5, v6
				move_mask v6, s4, v7
				move_mask v7, s3, v3
				move v8, 0

				; Load memory pointers
				load_32 s0, _data_ptr
				move v0, s0

				move s8, 1
				shl s8, s8, 16
				sub_i s8, s8, 1
		loop0: 	add_i_mask v0, s8, v0, 8
				shr s8, s8, 1
				btrue s8, loop0

				; Duplicate into computed register addresses
				move v1, v0
				move s1, s0
		
				; Compute initial code branch address
				getcr s2, 0
				shl s2, s2, 2
				lea s3, branch_addrs
				add_i s2, s2, s3
				load_32 s2, (s2)
				move pc, s2
	_data_ptr:	.long data

	branch_addrs: .long start_strand0, start_strand1, start_strand2, start_strand3

	''')

	for strand in range(4):
		file.write('start_strand%d: ' % strand)
		labelIdx = 1
		for x in range(numInstructions):
			file.write(str(labelIdx + 1) + ': ')
			labelIdx = (labelIdx + 1) % 6
		
			if random.randint(0, 7) == 0:
				# Computed pointer
				if random.randint(0, 1) == 0:
					file.write('\t\tadd_i s1, s0, ' + str(random.randint(0, 16) * 64) + '\n')
				else:
					file.write('\t\tadd_i v1, v0, ' + str(random.randint(0, 16) * 64) + '\n')
				
				continue
			
			instType = random.random()
			if instType < 0.5:
				# Arithmetic
				mnemonic = random.choice(BINOPS)
				if mnemonic[-2:] == '_f':
					typed, typea, typeb, suffix = random.choice(FFORMS)
				else:
					typed, typea, typeb, suffix = random.choice(IFORMS)

				dest = random.randint(2, 8)
				rega = random.randint(2, 8)
				regb = random.randint(2, 8)
				maskreg = random.randint(2, 8)
				opstr = '\t\t' + mnemonic + suffix + ' ' + typed + str(dest) + ', '
				if suffix != '':
					opstr += 's' + str(maskreg)	+ ', ' # Add mask register
		
				opstr += typea + str(rega) + ', '
				if typeb == 'i':
					opstr += str(random.randint(0, 0x1ff))	# Immediate value
				else:
				 	opstr += typeb + str(regb)

				file.write(opstr + '\n')
			elif instType < 0.9:
				# Memory
				opType = random.randint(0, 2)
				ptrReg = random.randint(0, 1)
				opstr = 'load' if random.randint(0, 1) else 'store'
			
				if opType == 0:
					# Block vector
					opstr += '_v v' + str(random.randint(2, 8)) + ', (s' + str(ptrReg) + ')'
				elif opType == 1:
					# Scatter/gather
					if opstr == 'load':
						opstr += '_gath'
					else:
						opstr += '_scat'

					maskType = random.randint(0, 1)
					if maskType == 1:
						opstr += '_mask'
	
					opstr += ' v' + str(random.randint(2, 8)) 
					if maskType != 0:
						opstr += ', s' + str(random.randint(2, 8))
				
					opstr += ', (v' + str(ptrReg) + ')'
	 			else:
					# Scalar
					opstr += '_32 s' + str(random.randint(2, 8)) + ', (s' + str(ptrReg) + ')'
			
				file.write('\t\t' + opstr + '\n')
			else:
				# Branch
				branchType = random.randint(0, 2)
				if branchType == 0:
					file.write('\t\tgoto ' + str(random.randint(1, 6)) + 'f\n')
				elif branchType == 1:
					file.write('\t\tbtrue s' + str(random.randint(2, 8)) + ', ' + str(random.randint(1, 6)) + 'f\n')
				else:
					file.write('\t\tbfalse s' + str(random.randint(2, 8)) + ', ' + str(random.randint(1, 6)) + 'f\n')
			
		file.write('''
		1: nop
		2: nop
		3: nop
		4: nop
		5: nop
		6: nop
		nop
		nop
	
		''')
		
		file.write('setcr s0, 29')
		for x in range(8):
			file.write('\t\tnop\n')

		file.write('1:\tgoto 1b\n')
	
	file.write('.align 64\n')
	file.write('data:')
	for x in range(4096):
		if (x & 7) == 0:
			file.write('\n.long ')
		else:
			file.write(', ')

		file.write(hex(random.randint(0, 0xffffffff)) + ' ')

	file.close()

parser = argparse.ArgumentParser()
parser.add_argument('-o', nargs=1, default=['random.s'], help='File to write result into', type=str)
parser.add_argument('-m', nargs=1, help='Write multiple test files', type=int)
parser.add_argument('-n', nargs=1, help='number of instructions to generate per thread', type=int,
	default=[0x1000])
args = vars(parser.parse_args())
numInstructions = args['n'][0]

if args['m']:
	for x in range(args['m'][0]):
		filename = 'random%04d.s' % x
		print 'generating ' + filename
		generate_test(filename, numInstructions)
else:
	generate_test(args['o'][0], numInstructions)



